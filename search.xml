<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTP中POST、GET、PUT、DELETE的区别]]></title>
    <url>%2F2018%2F05%2F27%2Fhttp%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[URL是什么:统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 HTTP定义了与服务器交互的不同的方法，最基本的是POST、GET、PUT、DELETE，而URL描述了一个网络上资源，而post、delete、get、put就是对这个资源进行增、删、查、改的操作! GET请求会向数据库发送索取数据的请求来获取数据，该请求就像数据库的 select 操作一样，只用来查询数据，不会增加、修改数据，不会影响资源的内容。 PUT请求是向服务器端发送数据的，从而改变内容，该请求就像数据库的 update 操作一样，用来修改数据的内容，但是不会增加数据的条数。(在Restful中PATCH请求同样是修改数据,不同的是,PUT类似于将某条(某行)数据全部提出进行修改后全部提交,而PATCH类似于将某列或某几列的内容修改后提交,该请求是一个局部更新，后端仅更新接收到的字段。如果进行部分修改显然PATCH是更优的选择!) POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的条数，就像数据库的 insert 操作一样，会创建新的内容。几乎目前所有的提交操作都是用POST请求的。 DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的 delete 操作。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript基础]]></title>
    <url>%2F2018%2F05%2F27%2FJavascript%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Javascript中有六种数据类型：字符串 string数字 number布尔 boolean对象 object （包括数组new array、函数function()、时间对象new Data()）空 null未定义 undefined Javascript:变量命名的规则(见名知义，驼峰命名法)1、数字、下划线、字母、$,组成，数字不能放在开头2、不能与关键字、保留字重合3、大小写敏感 Javascript注释：//表示单行注释/ /表示多行注释 Javascript运算符：number类型类似于Python中的浮点型float,如果要定义为整数类型，需用：parseInt()没有整除运算 //是注释理解++，–：var a = 3 var b = 3 var c = a++(先把a的值赋给了c，然后在给a+1，这样，c现在=3，而a=4) var c = ++b(先给b+1再赋值给c，所以c,b现在都=4)===(严格等)： 绝对等于（值和类型均相等）a = 5 那么a == ‘5’是true!==(严格不等)： 不绝对等于（值和类型有一个不相等，或两个都不相等）a = 5 那么a!== 5 是ture&amp;&amp;: 短路与 a&gt;0 &amp;&amp; a&lt;10 一个不成立就不再往下执行&amp;： 逻辑与 and||: 短路或 a10 一个成立就不再往下执行|： 逻辑或 or!: 类似于not a = ture !a就代表false a = 100 !!a就代表ture其他的与python相同switch 中的 case 是不带隐藏转换的 a = 5, switch(a){case’5’: ;case 5: ; default: ;}只执行后面case 5 Javascript 中的条件语句：if(){}; if(){}else{}; if(){}else if{}else{}; switch(){case: case: default:} Javascript 中的循环：for: for(){}; (){} 中间绝对不能写 ‘;’while: while(){}; (){} 中间绝对不能写 ‘;’do while: do{}while(); 这样无论如何至少会执行一次 Javascript 中生成随机数：Math.random() * ( max - min + 1) + min 表示生成[min,max]的随机数 Javascript 中定义函数：function foo(参数){} 多个参数用逗号隔开 参数也可以赋默认值 function foo(a=10, b=20){return a+b;} 返回30 Javascript 中json格式，创建对象的语法 创建对象的字面量方法：第一种：var stu1 = { name:’小张’ , age: 18, study: function(courseName){ window.alert(this.name+’正在学习’+courseName) }, watchAv: function(){ if (this.age &gt;= 18){ window.alert(this.name+’正在看东京冷’) }else{ window.alert(this.name+’只有看熊出没’) } } }; stu1.study(‘语文’); stu1.watchAv(); 第二种：var stu1 = new object(); new object()是一个函数stu1.name = ‘小张’;stu1.age = 18;stu1.study = function(courseNmae){ } 创建对象的构造器方法 创建同种类型的多个对象： 第一种：function Student(name, age){ this.name = name; this.age = age; this.study = function(courseName){ window.alert(this.name+’正在学习’+courseName) }; this.watch = function(){ if (this.age &gt;= 18){ window.alert(this.name+’正在看东京冷’) } else { window.alert(this.name+’只有看熊出没’) } };}var stu1 = new Student(‘小张’,18);var stu2 = new Student(‘jmd’,25);stu1.study(‘语文’);stu1.watchAv(); 第二种：可能更好function Student(name, age){ this.name = name; this.age = age; }; Student.prototye.study = function(courseName){ window.alert(this.name+’正在学习’+courseName); }; Student.propotype.watch = function(){ if (this.age &gt;= 18){ window.alert(this.name+’正在看东京冷’) } else { window.alert(this.name+’只有看熊出没’) } };};var stu1 = new Student(‘小张’,18);var stu2 = new Student(‘jmd’,25);stu1.study(‘语文’);stu1.watchAv(); 总结：在Javascript中函数是第一位（做什么都需要借助函数来完成创建）; Javascript 中自带的类：方法就是发给类的消息window window.alert(‘’) var a = window.prompt(‘输入：’); window.alert(a) 弹出输入的内容 window.comfirm(‘’) 调确认框 window.print()调打印机 window.close() 一般不用，有浏览器兼容问题 window.open(‘url’,’name’); 一般浏览器会自动屏蔽弹窗 重要的：window.location.href= window.setTimeout(函数，时间) 时间以毫秒为单位]]></content>
      <categories>
        <category>Javascript</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的random]]></title>
    <url>%2F2018%2F05%2F26%2FPython_Random%2F</url>
    <content type="text"><![CDATA[python中random模块可以生成随机数或随机顺序或随机选择我们常用的有random, randint, randrange, shuffle, sample, uniform，choicerandom: 随机生成 [0,1) 的实数123import randomx = random.random()print(x) 0.9065644990934733 randint: 随机生成 [min,max] 范围内的整数123import randomx = random.randint(1, 100)print(x) 21 randrange:随机生成[start, stop,step]范围内的整数 设置step可以规定步长1234import randomfor _ in range(10): # 通过循环十次看看随机生成的效果 x = random.randrange(1, 100, 2)# 随机生成一到一百的奇数 print(x, end=' ') # 通过设置end让结果打印在一排 53 27 1 51 31 65 13 15 87 93 uniform：随机生成[min,max]范围内的浮点数123import randomx = random.uniform(1,10)print(x) 9.11079652346942 shuffle: 将列表的顺序打乱（列表按随机排序）1234import randomlist1 = [1,2,3,4,5,6,7,8,9,10]random.shuffle(list1) # 打乱列表顺序print(list1) # 原有列表已经被随机排序 [1, 6, 3, 7, 8, 5, 9, 4, 10, 2] sample:从容器中随机选出指定数量的元素，容器可以是列表、字符串、元组12345678910111213import randomlist1 = [1,2,3,4,5,6,7,8,9,10]string1 = 'abcdefghijk'tuple1 = (1,2,3,4,5,6,7,8,9,10)x = random.sample(list1,3) # 随机在list1中选取3个元素y = random.sample(string1,3) # 随机在字符串中选取三个元素z = random.sample(tuple1,2) # 随机在元组中选取两个元素print(x)print(y)print(z)print(list1) # sample并不改变原有容器print(string1)print(tuple1) [6, 4, 7] [&apos;h&apos;, &apos;g&apos;, &apos;k&apos;] [1, 6] [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] abcdefghijk (1, 2, 3, 4, 5, 6, 7, 8, 9, 10) choice:从容器中随机选取一个元素，容器可以是列表、字符串、元组12345678910111213import randomlist1 = [1,2,3,4,5,6,7,8,9,10]string1 = 'abcdefghijk'tuple1 = (1,2,3,4,5,6,7,8,9,10)x = random.choice(list1) # 随机在list1中选取元素y = random.choice(string1) # 随机在字符串中选取元素z = random.choice(tuple1) # 随机在元组中选取元素print(x)print(y)print(z)print(list1) # choice并不改变原有容器print(string1)print(tuple1) 1 c 8 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] abcdefghijk (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F05%2F26%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式又称规则表达式，英语：Regular Expression，在代码中常简写为regex\regexp\RE,作为计算机科学的一个概念，正则表达式通常被用来检索、替换那些符合某个规则的文本，是对字符串进行操作的一种逻辑公式。1、可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。2、 基于模式匹配从字符串中提取子字符串。3、可以查找文档内或输入域内特定的文本。 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \w 匹配字母/数字/下划线 b\wt 可以匹配bat / b1t / b_t等但不能匹配b#t \s 匹配空白字符（包括\r、\n、\t等） love\syou 可以匹配love you \d 匹配数字 \d\d 可以匹配01 / 23 / 99等 \b 匹配单词的边界 \bThe\b 可以匹配The ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串 $ 匹配字符串的结束 .exe$ 可以匹配.exe结尾的字符串 \W 匹配非字母/数字/下划线 b\Wt 可以匹配b#t / b@t等,但不能匹配but / b1t / b_t等 \S 匹配非空白字符 love\Syou 可以匹配love#you等,但不能匹配love you \D 匹配非数字 \d\D 可以匹配9a / 3# / 0F等 \B 匹配非单词边界 \Bio\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 [^] 匹配不在字符集中的任意单一字符 [^aeiou] 可以匹配任一非元音字母字符 * 匹配0次或多次 \w* + 匹配1次或多次 \w+ ? 匹配0次或1次 \w? {N} 匹配N次 \w{3} 可以匹配aaa,abc,cba {M,} 匹配至少M次 \w{3,} 可以匹配aaaaa,abduns {M,N} 匹配至少M次至多N次 \w{3,6} \ 分支 foo\ bar 可以匹配foo或者bar (?#) 注释 (exp) 匹配exp并捕获到自动命名的组中 (?exp) 匹配exp并捕获到名为name的组中 (?:exp) 匹配exp但是不捕获匹配的文本 (?=exp) 匹配exp前面的位置 \b\w+(?=ing) 可以匹配I’m dancing中的danc (?&lt;=exp) 匹配exp后面的位置 (?&lt;=\bdanc)\w+\b 可以匹配I love dancing and reading中的第一个ing (?!exp) 匹配后面不是exp的位置 *? 重复任意次，但尽可能少重复 +? 重复1次或多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {M,N}? 重复M到N次，但尽可能少重复 {M,}? 重复M次以上，但尽可能少重复]]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统下的Python安装]]></title>
    <url>%2F2018%2F05%2F25%2FLinux%E4%B8%8B%E5%AE%89%E8%A3%85Python%2F</url>
    <content type="text"><![CDATA[Linux系统下的Python安装：在Linux系统中一般默认已经安装有python的2.X 版本，进入系统后，在输入执行：python 退出按Ctrl+z如下图所示，我的Centos7中装有Python 2.7.5版本。 我主要介绍的是Python3.X版本的安装，以及如何配置环境变量。 源文件安装过程：在python官网中的download找到你需要的python版本，https://www.python.org/ 这是官网地址；我需要的是Python 3.6.5 版本，找到如下图所示的位置，前两个就是你需要的Linux系统下的安装包； 如选择XZ的压缩文件，点击右键复制链接地址；然后回到你的Linux系统，注意是否在你的用户目录下，不然下载后容易将系统弄乱而不自知，回到自己的用户目录用 cd ~然后输入执行 wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tar.xz (或粘贴你复制的链接地址)下载完成后 输入 ll 回车 看是否已经有了Python-3.6.5.tar.xz的压缩文件 然后执行如下图一、二行所示命令，解压你的python3.6.5然后再次输入 ll 回车 看是否已经有了Python-3.6.5的文件夹，输入第四行命令，进入文件夹。 然后先安装依赖文件：输入执行 yum -y install zlib*依次输入： ./configure –prefix=/usr/local/python3.6 –enable-optimizationsmake &amp;&amp; make install 安装python3.6;现在你已经安装完成接下来配置环境变量，我用的是创建软链接的方式（有点类似于windows系统中的创建快捷方式）依次执行下图命令，这样你的python3与pip3的环境变量便配置完成 cd ~ 回到你的主目录，输入执行python3 看看你的python3是否安装好了？退出按Ctrl+z]]></content>
      <categories>
        <category>Linux</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python--多线程]]></title>
    <url>%2F2018%2F05%2F25%2FPython%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多线程类似于同时执行多个不同程序，多线程运行有如下优点：1、使用线程可以把占据长时间的程序中的任务放到后台去处理。2、用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度程序的运行速度可能加快3、在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们可以释放一些珍贵的资源如内存占用等等。4、线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。线程可以被抢占（中断）。在其他线程正在运行时，线程可以暂时搁置（也称为睡眠） – 这就是线程的退让。Python中使用线程有两种方式：函数或者用类来包装线程对象。下面我以两个简单的示例来解释这两种方式：模拟用多线程下载文件，用的是函数的方法： 1234567891011121314151617181920212223242526from random import randintfrom threading import Threadfrom time import time, sleepdef download(filename): print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 用时%d秒' % (filename, time_to_download))def main(): start = time() # 开始的时间点 t1 = Thread(target=download, args=('A文件',)) # 注意字符串后面的逗号，表示传入的是元组 t1.start() # 启动下载A文件的线程 t2 = Thread(target=download, args=('B文件',)) t2.start() t1.join() # 等待执行结束 t2.join() # 等待执行结束 end = time() # 结束的时间点 print('总共耗费了%.5f秒' % (end - start))if __name__ == '__main__': main() 用多线程写的赛车动画，五个线程控制五辆由色块表示的小车移动，这样小车可以同时移动，而不是一辆一辆依次移动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import pygamefrom random import uniform, randintfrom threading import Threadclass Car(object): def __init__(self, x, y): self._color = [randint(0, 255), randint(0, 255), randint(0, 255)] self._x = x self._y = y @property def x(self): return self._x def move(self): self._x += uniform(0.5, 3) def head(self): return self._x + 20 def draw(self, screen): pygame.draw.rect(screen, self._color, (self._x, self._y, 20, 20), 0) def run(self, screen): self.move() self.draw(screen)class Mythread(Thread): def __init__(self, car, screen): super().__init__() self._car = car self._screen = screen def run(self): Car.move(self._car) Car.draw(self._car, self._screen)def main(): pygame.init() screen = pygame.display.set_mode([600, 500]) pygame.display.set_caption('赛车游戏') screen.fill([255, 255, 255]) pygame.draw.line(screen, [0, 0, 0], (37, 0), (37, 500), 5) pygame.draw.line(screen, [255, 0, 0], (580, 0), (580, 500), 5) cars = [] for i in range(5): car = Car(20, 50+100*i) cars.append(car) for car in cars: car.draw(screen) pygame.display.flip() running = True gameover = False def game_over(c1): nonlocal gameover if c1.head() &gt; 580: gameover = True def refresh(): screen.fill((255, 255, 255)) pygame.draw.line(screen, [0, 0, 0], (37, 0), (37, 500), 5) pygame.draw.line(screen, [255, 0, 0], (580, 0), (580, 500), 5) for _ in cars: Mythread(_, screen).start() pygame.display.flip() while running: for event in pygame.event.get(): if event.type == pygame.QUIT: running = False if event.type == pygame.KEYDOWN: while not gameover: for car in cars: game_over(car) refresh() pygame.display.flip() pygame.quit()if __name__ == '__main__': main()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符串]]></title>
    <url>%2F2018%2F05%2F24%2FPyhon%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Python中的字符串类型的常用方法在字符串中查找索引方法包括： .index()、.rindex、.find()、.rfind() 方法中可以规定查找的具体起点索引位置，终点索引位置find 与 rfind 的区别一个从左向右找，一个从右到左找，它们都只返回第一个查找到的位置 同理 index与rindexfind 与 index 的区别在于，如果在字符串中没有查找到目标字符串，find将会返回整型 -1 而index将报出ValueError的错误 123456789text = 'abba'print(text.index('a')) print(text.rindex('a'))print(text.index('a',1))print(text.find('a'))print(text.find('a',1))print(text.rfind('a'))print(text.find('c'))print(text.index('c')) 0 3 3 0 3 3 -1 --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-4-4bb2a984ce9c&gt; in &lt;module&gt;() 7 print(text.rfind(&apos;a&apos;)) 8 print(text.find(&apos;c&apos;)) ----&gt; 9 print(text.index(&apos;c&apos;)) ValueError: substring not found 在字符串中插入字符串.join() 插入间隔字符串，将字符串一一隔开.format() 在字符串中加入{}然后用.format( )在括号内依次插入在字符串中加入%s 代表字符串 %d 代表数字 后用 % 连接你要插入的 123456a = ' ' # 包含一个空格的字符串b = '面朝大海春暖花开'print(b)print(a.join(b))print('挑水&#123;&#125;柴周&#123;&#125;世界'.format('劈','游'))print('%d个和尚挑%s,%d个和尚%s' % (1,'水喝',2,'没水喝')) 面朝大海春暖花开 面 朝 大 海 春 暖 花 开 挑水劈柴周游世界 1个和尚挑水喝,2个和尚没水喝 在字符串中判断（此处不谈正则表达式）.isalnum()判断是否由字母与数字构成.isalpha()判断是否由字母构成.isdigit()判断是否是数字构成.islower()判断是否全是小写字母.isupper()判断是否全是大写字母.endswith()以什么结束.startswith()以什么开始 1234567print('abc123'.isalnum()) # 判断是否由字母与数字构成print('abc123'.isalpha()) # 判断是否由字母构成print('123'.isdigit()) # 判断是否是数字构成print('abc'.islower()) # 判断是否全是小写字母print('abc'.isupper()) # 判断是否全是大写字母print('abc'.endswith('c')) # 以什么结束print('abc'.startswith('a')) # 以什么开始 True False True True False True True 将字符串拆分成列表.split() 12text = '姓名，年龄，学历，简历' # 注意我用的汉语输入法中的逗号print(text.split('，')) [&apos;姓名&apos;, &apos;年龄&apos;, &apos;学历&apos;, &apos;简历&apos;] 将字符串中的字符替换.replace() 将原来的字符串替换为新的字符串.capitalize() 将原来的字符串首字母进行大写处理 同理 .title().upper() 全部转换为大写字母.lower() 全部转换为小写字母 1234print('I want to work'.replace('work','sleep'))print('i want to work'.capitalize())print('i want to work'.upper())print('I wAnt to work'.lower()) I want to sleep I want to work I WANT TO WORK i want to work]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2018%2F05%2F22%2Fgit%2F</url>
    <content type="text"><![CDATA[git常用命令: 命令 说明 git clone ‘远端克隆地址’ 将仓库克隆并创建链接到本地 git checkout -b ‘分支名’ 创建并进入分支 git checkout ‘分支名’ 进入分支 git status 查看修改文件状态 git add ‘文件名’ 添加要上传的文件 git add . 添加所有文件 git commit -m ‘说明’ 提交并添加文件说明 git push origin ‘分支名’ 提交文件到远端的分支中 git pull origin ‘分支名’ 如果远端修改了文件二本地并未更新,需pull从远端先把本地更新了才能push到远端分支 git merge ‘分支名’ 将你当前所在分支与’分支名’分支进行融合 git stash 缓存更改 git stash list 查看缓存片段 git stash apply stash@{0} 还原缓存代码 git log 查看提交的日志 git -a ‘版本号’ -m ‘说明’ 提交上线版本标签及说明 git push origin ‘标签名’ 将上线版本push到远端 git show commit-id 查看某次提交的内容 git reset –hard 退回到以前的版本 git branch -D ‘分支名’ 删除该分支 git push origin –delete ‘分支名’ 删除远端分支 git push origin –delete tag ‘版本号’ 删除远端上线版本 git diff ‘分支名’ ‘分支名’ 看两个分支间的差异]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django/Flask简介]]></title>
    <url>%2F2018%2F05%2F20%2FDjango-Flask%E7%AE%80%E4%BB%8B-md%2F</url>
    <content type="text"><![CDATA[Python网络框架网络框架指一组python包,它能够让开发者更加专注于网站应用业务逻辑的开发,而无须处理网络应用层的协议、线程、进程等方面，从而提高开发者的工作效率以及网络应用程序的质量。目前Python语言的十几个开发框架中,几乎所有的全栈网络框架都强制或引导开发者使用MVC架构开发Web应用.Python的四种主流框架为:Django/Flask/Tornado/Twisted此篇博文围绕Django/Flask讲解各自特点以及主要应用. MVC: MVC–M(Model):封装与应用程序相关的业务逻辑的数据及对数据的处理方法,是处理数据逻辑的部分.Model提供功能性接口,通过接口访问数据; MVC–V(View):负责数据的显示和呈现,View是对用户的直接输出; MVC–C(Controller):从用户端收集用户的输入,可以看作View的反向功能,Controller将用户作出的改变返回给Model,由Model在返回给View,Model作为数据中心,从而提高数据的一致性; ORM(Object-Relational Mapping 对象关系映射):是在关系型数据库和业务实体对象之间的映射,即开发者对对象与属性进行操作,而不用再去写复杂的sql语句,ORM必须具备三方面功能: 映射技术: 数据类型映射 类映射 关系映射 CRUD操作:(ORM将这些调用转换为SQL语句,通过引擎发送给数据库执行,将结果记录并转换为对象) create增加 Retrieve读取 Upadate更新 Delete删除 缓存优化:由于数据库的操作通常比较耗时,所以大多数ORM提供数据缓存优化的功能 DjangoDjango发布于2003年,是当前最成熟完整最广泛以及最富盛名的Python网络框架.Django定义了服务发布;路由映射;模板编程;数据处理的一整套功能.遵循MVC架构. 优点: 各模块之间结合紧密; 功能强大而相对封闭; 完整的在线文档及健全的开发社区; 具备自带优秀的ORM; 强大的URL映射技术; 后台管理系统自动生成; 用户多,第三方库丰富; 成熟稳定完善,适合企业级网站开发 缺点: 由于自带的丰富功能造成的冗余/耦合程度较高; 可能相对较重,比如开发小应用时,可能会不够灵活/自由; FlaskFlask发布于2010年,它吸收了其他框架的优点并且把自己的主要领域定义在微小项目上.作为微框架,安装时不会自动安装ORM数据组件等其他组件,所以开发者需要自行安装需要的组件. 优点: 内置开发服务器和调试器:Flask默认处于调试状态,运行时会将错误返回给控制台以及HTTP客户端; 与Python单元测试功能无缝连接:测试程序可以模拟进行HTTP访问的客户端来调用Flask路由处理函数,并且获取函数的输出来进行自定义的验证; 使用Jinja2模板,强大程度略高于Django的自带模板; 完全兼容WSGI 1.0 标准; 给予Unicode编码; 完美适合小型网站; 第三方库同样丰富; 开发灵活程度高,入门简单; 缺点: 很多东西需要从头构建; 用的第三方插件可能要踩的坑较多;]]></content>
      <categories>
        <category>Django</category>
        <category>Flask</category>
        <category>Web</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web</tag>
        <tag>Django</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
</search>
